use snmp_mp::{MsgProcessingResult, ObjectIdent, SnmpMsg, VarBind, VarValue};

#[test]
fn it_encodes_snmp_msg() {
    let security_params = [
        0x30, 0x3a, 0x04, 0x11, 0x80, 0x00, 0x1f, 0x88, 0x80, 0xfa, 0xa8, 0x11, 0x60, 0x0f, 0xa2,
        0xc5, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x04, 0x02, 0x03, 0x01, 0x1f, 0x27, 0x04,
        0x0d, 0x64, 0x61, 0x76, 0x69, 0x64, 0x64, 0x75, 0x66, 0x72, 0x65, 0x73, 0x6e, 0x65, 0x04,
        0x0c, 0x14, 0xdb, 0x5e, 0xec, 0xdd, 0x43, 0xb1, 0xc5, 0x1f, 0x7c, 0x42, 0xdf, 0x04, 0x00,
    ];

    let mut msg = SnmpMsg::new(837040343);
    msg.set_reportable_flag()
        .set_auth_flag()
        .set_security_params(&security_params);

    if let Some(scoped_pdu) = msg.scoped_pdu_data.plaintext_mut() {
        let oid = ObjectIdent::from_slice(&[0x01, 0x03, 0x06, 0x01, 0x02, 0x01, 0x01, 0x01, 0x00]);
        let var_bind = VarBind::with_value(oid, VarValue::Unspecified);
        let var_binds = vec![var_bind];

        let engine_id = [
            0x80, 0x00, 0x1F, 0x88, 0x80, 0xFA, 0xA8, 0x11, 0x60, 0x0F, 0xA2, 0xc5, 0x5E, 0x00,
            0x00, 0x00, 0x00,
        ];

        scoped_pdu
            .set_request_id(1918134953)
            .set_engine_id(&engine_id)
            .set_var_binds(var_binds);
    }

    let encoded_msg = msg.encode();
    let expected = vec![
        0x30, 0x81, 0x89, 0x02, 0x01, 0x03, 0x30, 0x11, 0x02, 0x04, 0x31, 0xE4, 0x38, 0xD7, 0x02,
        0x03, 0x00, 0xFF, 0xE3, 0x04, 0x01, 0x05, 0x02, 0x01, 0x03, 0x04, 0x3C, 0x30, 0x3A, 0x04,
        0x11, 0x80, 0x00, 0x1F, 0x88, 0x80, 0xFA, 0xA8, 0x11, 0x60, 0x0F, 0xA2, 0xC5, 0x5E, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x01, 0x04, 0x02, 0x03, 0x01, 0x1F, 0x27, 0x04, 0x0D, 0x64, 0x61,
        0x76, 0x69, 0x64, 0x64, 0x75, 0x66, 0x72, 0x65, 0x73, 0x6E, 0x65, 0x04, 0x0C, 0x14, 0xDB,
        0x5E, 0xEC, 0xDD, 0x43, 0xB1, 0xC5, 0x1F, 0x7C, 0x42, 0xDF, 0x04, 0x00, 0x30, 0x33, 0x04,
        0x11, 0x80, 0x00, 0x1F, 0x88, 0x80, 0xFA, 0xA8, 0x11, 0x60, 0x0F, 0xA2, 0xC5, 0x5E, 0x00,
        0x00, 0x00, 0x00, 0x04, 0x00, 0xA0, 0x1C, 0x02, 0x04, 0x72, 0x54, 0x6A, 0xA9, 0x02, 0x01,
        0x00, 0x02, 0x01, 0x00, 0x30, 0x0E, 0x30, 0x0C, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x02, 0x01,
        0x01, 0x01, 0x00, 0x05, 0x00,
    ];

    assert_eq!(encoded_msg, expected);
}

#[test]
fn it_decodes_snmp_msg() -> MsgProcessingResult<()> {
    let encoded_msg = vec![
        0x30, 0x81, 0x89, 0x02, 0x01, 0x03, 0x30, 0x11, 0x02, 0x04, 0x31, 0xE4, 0x38, 0xD7, 0x02,
        0x03, 0x00, 0xFF, 0xE3, 0x04, 0x01, 0x05, 0x02, 0x01, 0x03, 0x04, 0x3C, 0x30, 0x3A, 0x04,
        0x11, 0x80, 0x00, 0x1F, 0x88, 0x80, 0xFA, 0xA8, 0x11, 0x60, 0x0F, 0xA2, 0xC5, 0x5E, 0x00,
        0x00, 0x00, 0x00, 0x02, 0x01, 0x04, 0x02, 0x03, 0x01, 0x1F, 0x27, 0x04, 0x0D, 0x64, 0x61,
        0x76, 0x69, 0x64, 0x64, 0x75, 0x66, 0x72, 0x65, 0x73, 0x6E, 0x65, 0x04, 0x0C, 0x14, 0xDB,
        0x5E, 0xEC, 0xDD, 0x43, 0xB1, 0xC5, 0x1F, 0x7C, 0x42, 0xDF, 0x04, 0x00, 0x30, 0x33, 0x04,
        0x11, 0x80, 0x00, 0x1F, 0x88, 0x80, 0xFA, 0xA8, 0x11, 0x60, 0x0F, 0xA2, 0xC5, 0x5E, 0x00,
        0x00, 0x00, 0x00, 0x04, 0x00, 0xA0, 0x1C, 0x02, 0x04, 0x72, 0x54, 0x6A, 0xA9, 0x02, 0x01,
        0x00, 0x02, 0x01, 0x00, 0x30, 0x0E, 0x30, 0x0C, 0x06, 0x08, 0x2B, 0x06, 0x01, 0x02, 0x01,
        0x01, 0x01, 0x00, 0x05, 0x00,
    ];
    let msg = SnmpMsg::decode(&encoded_msg)?;

    assert_eq!(msg.id(), 837040343);
    assert!(msg.is_reportable());
    assert!(msg.is_auth());

    let security_params = [
        0x30, 0x3a, 0x04, 0x11, 0x80, 0x00, 0x1f, 0x88, 0x80, 0xfa, 0xa8, 0x11, 0x60, 0x0f, 0xa2,
        0xc5, 0x5e, 0x00, 0x00, 0x00, 0x00, 0x02, 0x01, 0x04, 0x02, 0x03, 0x01, 0x1f, 0x27, 0x04,
        0x0d, 0x64, 0x61, 0x76, 0x69, 0x64, 0x64, 0x75, 0x66, 0x72, 0x65, 0x73, 0x6e, 0x65, 0x04,
        0x0c, 0x14, 0xdb, 0x5e, 0xec, 0xdd, 0x43, 0xb1, 0xc5, 0x1f, 0x7c, 0x42, 0xdf, 0x04, 0x00,
    ];
    assert_eq!(msg.security_params(), &security_params[..]);

    Ok(())
}
